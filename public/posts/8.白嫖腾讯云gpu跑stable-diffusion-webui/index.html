<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>白嫖腾讯云GPU跑Stable Diffusion | WallBreakerNO4的博客</title>
<meta name="keywords" content="">
<meta name="description" content="AI 绘画并不是一个离我们很远的话题，随着基于 diffusion 架构的 stable diffusion 的诞生，各式各样的绘图模型如井喷式诞生。如果想在本地跑 AIGC 的绘画软件，那么一块强大的 GPU 是必不可少的。但不是所有人都是臭打游戏的拥有一块 GPU，因此我在这里介绍如何白嫖腾讯云的免费 GPU 来运行 Stable Diffusion WebUI

感谢 Linux Do 上的网友将这个白嫖的方法分享出来

准备
首先打开 https://ide.cloud.tencent.com/dashboard/gpu-workspace ，登录后便能进入到这一个界面（图中是我已经创建好的，请忽略）：



腾讯云在 Cloud Studio 中提供了一个月 10000 分钟的 GPU 时长（2025 年 1 月 1 日后），免费的 GPU 配置为 Tesla T4，拥有 16G 的显存。这用于跑 Stable Diffusion WebUI 已经绰绰有余了。
美中不足的是，这个在排除了系统自带占用后，只有 30G 的空间，稍微有点小

新建一个工作空间：


名称随便，能记住就行，模板选择 Pytorch：


进入新建好的工作空间 VScode 换皮


将左侧的示例删除：


新建一个终端：




安装 WebUI
克隆项目（使用 Github Proxy 代理）到本地并进入 webui 文件夹：">
<meta name="author" content="WallBreakerNO4">
<link rel="canonical" href="http://100.119.72.3:1313/posts/8.%E7%99%BD%E5%AB%96%E8%85%BE%E8%AE%AF%E4%BA%91gpu%E8%B7%91stable-diffusion-webui/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css" integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://100.119.72.3:1313/assets/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://100.119.72.3:1313/assets/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://100.119.72.3:1313/assets/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://100.119.72.3:1313/assets/apple-touch-icon.png">
<link rel="mask-icon" href="http://100.119.72.3:1313/assets/mstile-150x150.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://100.119.72.3:1313/posts/8.%E7%99%BD%E5%AB%96%E8%85%BE%E8%AE%AF%E4%BA%91gpu%E8%B7%91stable-diffusion-webui/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="白嫖腾讯云GPU跑Stable Diffusion" />
<meta property="og:description" content="AI 绘画并不是一个离我们很远的话题，随着基于 diffusion 架构的 stable diffusion 的诞生，各式各样的绘图模型如井喷式诞生。如果想在本地跑 AIGC 的绘画软件，那么一块强大的 GPU 是必不可少的。但不是所有人都是臭打游戏的拥有一块 GPU，因此我在这里介绍如何白嫖腾讯云的免费 GPU 来运行 Stable Diffusion WebUI

感谢 Linux Do 上的网友将这个白嫖的方法分享出来

准备
首先打开 https://ide.cloud.tencent.com/dashboard/gpu-workspace ，登录后便能进入到这一个界面（图中是我已经创建好的，请忽略）：



腾讯云在 Cloud Studio 中提供了一个月 10000 分钟的 GPU 时长（2025 年 1 月 1 日后），免费的 GPU 配置为 Tesla T4，拥有 16G 的显存。这用于跑 Stable Diffusion WebUI 已经绰绰有余了。
美中不足的是，这个在排除了系统自带占用后，只有 30G 的空间，稍微有点小

新建一个工作空间：


名称随便，能记住就行，模板选择 Pytorch：


进入新建好的工作空间 VScode 换皮


将左侧的示例删除：


新建一个终端：




安装 WebUI
克隆项目（使用 Github Proxy 代理）到本地并进入 webui 文件夹：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://100.119.72.3:1313/posts/8.%E7%99%BD%E5%AB%96%E8%85%BE%E8%AE%AF%E4%BA%91gpu%E8%B7%91stable-diffusion-webui/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2025-01-18T00:27:00+00:00" />
<meta property="article:modified_time" content="2025-01-18T00:27:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="白嫖腾讯云GPU跑Stable Diffusion"/>
<meta name="twitter:description" content="AI 绘画并不是一个离我们很远的话题，随着基于 diffusion 架构的 stable diffusion 的诞生，各式各样的绘图模型如井喷式诞生。如果想在本地跑 AIGC 的绘画软件，那么一块强大的 GPU 是必不可少的。但不是所有人都是臭打游戏的拥有一块 GPU，因此我在这里介绍如何白嫖腾讯云的免费 GPU 来运行 Stable Diffusion WebUI

感谢 Linux Do 上的网友将这个白嫖的方法分享出来

准备
首先打开 https://ide.cloud.tencent.com/dashboard/gpu-workspace ，登录后便能进入到这一个界面（图中是我已经创建好的，请忽略）：



腾讯云在 Cloud Studio 中提供了一个月 10000 分钟的 GPU 时长（2025 年 1 月 1 日后），免费的 GPU 配置为 Tesla T4，拥有 16G 的显存。这用于跑 Stable Diffusion WebUI 已经绰绰有余了。
美中不足的是，这个在排除了系统自带占用后，只有 30G 的空间，稍微有点小

新建一个工作空间：


名称随便，能记住就行，模板选择 Pytorch：


进入新建好的工作空间 VScode 换皮


将左侧的示例删除：


新建一个终端：




安装 WebUI
克隆项目（使用 Github Proxy 代理）到本地并进入 webui 文件夹："/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://100.119.72.3:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "白嫖腾讯云GPU跑Stable Diffusion",
      "item": "http://100.119.72.3:1313/posts/8.%E7%99%BD%E5%AB%96%E8%85%BE%E8%AE%AF%E4%BA%91gpu%E8%B7%91stable-diffusion-webui/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "白嫖腾讯云GPU跑Stable Diffusion",
  "name": "白嫖腾讯云GPU跑Stable Diffusion",
  "description": "AI 绘画并不是一个离我们很远的话题，随着基于 diffusion 架构的 stable diffusion 的诞生，各式各样的绘图模型如井喷式诞生。如果想在本地跑 AIGC 的绘画软件，那么一块强大的 GPU 是必不可少的。但不是所有人都是臭打游戏的拥有一块 GPU，因此我在这里介绍如何白嫖腾讯云的免费 GPU 来运行 Stable Diffusion WebUI\n感谢 Linux Do 上的网友将这个白嫖的方法分享出来\n准备 首先打开 https://ide.cloud.tencent.com/dashboard/gpu-workspace ，登录后便能进入到这一个界面（图中是我已经创建好的，请忽略）： 腾讯云在 Cloud Studio 中提供了一个月 10000 分钟的 GPU 时长（2025 年 1 月 1 日后），免费的 GPU 配置为 Tesla T4，拥有 16G 的显存。这用于跑 Stable Diffusion WebUI 已经绰绰有余了。 美中不足的是，这个在排除了系统自带占用后，只有 30G 的空间，稍微有点小\n新建一个工作空间： 名称随便，能记住就行，模板选择 Pytorch： 进入新建好的工作空间 VScode 换皮 将左侧的示例删除： 新建一个终端： 安装 WebUI 克隆项目（使用 Github Proxy 代理）到本地并进入 webui 文件夹：\n",
  "keywords": [
    
  ],
  "articleBody": "AI 绘画并不是一个离我们很远的话题，随着基于 diffusion 架构的 stable diffusion 的诞生，各式各样的绘图模型如井喷式诞生。如果想在本地跑 AIGC 的绘画软件，那么一块强大的 GPU 是必不可少的。但不是所有人都是臭打游戏的拥有一块 GPU，因此我在这里介绍如何白嫖腾讯云的免费 GPU 来运行 Stable Diffusion WebUI\n感谢 Linux Do 上的网友将这个白嫖的方法分享出来\n准备 首先打开 https://ide.cloud.tencent.com/dashboard/gpu-workspace ，登录后便能进入到这一个界面（图中是我已经创建好的，请忽略）： 腾讯云在 Cloud Studio 中提供了一个月 10000 分钟的 GPU 时长（2025 年 1 月 1 日后），免费的 GPU 配置为 Tesla T4，拥有 16G 的显存。这用于跑 Stable Diffusion WebUI 已经绰绰有余了。 美中不足的是，这个在排除了系统自带占用后，只有 30G 的空间，稍微有点小\n新建一个工作空间： 名称随便，能记住就行，模板选择 Pytorch： 进入新建好的工作空间 VScode 换皮 将左侧的示例删除： 新建一个终端： 安装 WebUI 克隆项目（使用 Github Proxy 代理）到本地并进入 webui 文件夹：\ngit clone https://ghfast.top/https://github.com/lllyasviel/stable-diffusion-webui-forge.git cd stable-diffusion-webui-forge Github Proxy 项目的域名很容易被墙，请去项目最新发布地址查看可用域名，并将后续使用 Github Proxy 的域名替换\n将自带的 pytorch 删除（版本太老了），创建 venv 并安装最新版的 pytorch：\npip uninstall torch torchvision torchaudio python -m venv venv source venv/bin/activate pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu124 可能会比较慢，但国内没有 pytorch 的镜像源了，只能这样嗯下\n打开 stable-diffusion-webui-forge/modules/launch_utils.py 文件，将里面所有的 https://github.com 替换为 https://ghfast.top/https://github.com，在第一次启动 webui 安装插件时走镜像加速安装 使用 ctrl + H 进行替换\n安装工作空间缺失的组件（aria2 是用于下载模型的，如果你喜欢使用 wget 的话就不用安装）：\napt update \u0026\u0026 apt install aria2 google-perftools bc libgl1 -y 修改 stable-diffusion-webui-forge/webui-user.sh，取消 export COMMANDLINE_ARGS=\"\" 这一行的注释，并修改为：\nexport COMMANDLINE_ARGS=\"--listen --enable-insecure-extension-access --api --theme dark --cuda-malloc\" 进入 stable-diffusion-webui-forge/models/Stable-diffusion 下载模型：\n对于画二次元图片，我推荐 Laxhar Dream Lab 训练的 NoobAI-XL 系列模型：Huggingface 地址，Civitai 地址\ncd stable-diffusion-webui-forge/models/Stable-diffusion # 由于 HuggingFace 被墙，使用 HF-mirror 下载 aria2c -x 16 -o NoobAI-XL-Vpred-v1.0.safetensors \"https://hf-mirror.com/Laxhar/noobai-XL-Vpred-1.0/resolve/main/NoobAI-XL-Vpred-v1.0.safetensors?download=true\" # HuggingFace 下载链接 # aria2c -x 16 -o NoobAI-XL-Vpred-v1.0.safetensors \"https://huggingface.co/Laxhar/noobai-XL-Vpred-1.0/resolve/main/NoobAI-XL-Vpred-v1.0.safetensors?download=true\" 返回 webui 根目录，并启动 webui：\ncd /workspace/stable-diffusion-webui-forge/ ./webui.sh -f 由于是 root 身份，需要添加 -f 参数才能启动 webui\n终端出现类似以下输出时，webui 便启动成功了\nRunning on local URL: http://0.0.0.0:7860 To create a public link, set `share=True` in `launch()`. Startup time: 47.7s (prepare environment: 12.1s, launcher: 0.6s, import torch: 12.2s, initialize shared: 0.1s, other imports: 0.5s, load scripts: 2.2s, initialize google blockly: 14.1s, create ui: 2.6s, gradio launch: 1.4s, add APIs: 1.7s). 访问 WebUI 由于腾讯云的这个工作空间并不提供外部访问端口的功能，我们需要使用内网穿透工具来访问 webui。市面上有很多内网穿透服务，因此本章仅为抛砖引玉，不一定是最好的解决方案。\nWebUI 自带的穿透 实际上，WebUI 自带了一个内网穿透功能。WebUI 是基于 Gradio 构建的，而 Guadio 提供了一个公共的穿透服务。只需要修改 stable-diffusion-webui-forge/webui-user.sh 这个文件，同样修改 export COMMANDLINE_ARGS= 这一行，添加 --share 参数即可使用。\n这是最简单的方法，但有一个问题：Gradio 提供的服务器在海外，而由于腾讯云这个 ide 在大陆，内网穿透需要来回共两次，因此并不稳定\n使用 FRP 穿透 FRP 应该是市面上最常见的内网传统工具了，可以选择市面上免费的 frps 服务商或者用自己的服务器搭建一个。\n服务商 市面上也有很多服务商提供免费的 frps 服务，我在这里推荐几家我曾经用过的（没有 aff）：\nSAKURA FRP FreeFRP.NET 小鸡FRP内网穿透 如何使用这些服务商请看其对应文档，本文只介绍如何使用自己的服务器搭建 FRP 来访问 WebUI\n自己搭建 在搭建前，你需要拥有一个能从公网访问的服务器才能自建 frps（只需要两个端口，实际上提供 NATv4 入口的服务器也是可以的）\n我们可以使用 docker compose 来一把梭配置文件：\nservices: frps: logging: options: max-size: 16m restart: unless-stopped network_mode: host # 直接使用 host 模式一把梭 volumes: - './frps.toml:/etc/frp/frps.toml' container_name: frps image: snowdreamtech/frps 然后在同文件夹下编辑 frps.toml：\nbindPort = [FRP-port] auth.token = \"[FRP-token]\" 请将 [FRP-port] 和 [FRP-token] 替换为实际使用的端口和 token\n最后启动 docker 容器：\ndocker compose up -d 请注意开放服务器的防火墙端口，需要开放两个：[FRP-port]/tcp 和 7860/tcp\n回到腾讯云 IDE，让我们新建一个终端并创建一个文件夹来放 frpc 相关的文件：\ncd /workspace/ mkdir frp cd frp 使用 GitHub Proxy 从 FRP 仓库下载 amd64 架构的文件：\naria2c -x 16 -o frp_0.61.1_linux_amd64.tar.gz \"https://ghfast.top/https://github.com/fatedier/frp/releases/download/v0.61.1/frp_0.61.1_linux_amd64.tar.gz\" 解压文件：\ntar -zxvf frp_0.61.1_linux_amd64.tar.gz 创建 frpc.toml 文件并编辑：\nserverAddr = \"[IP-or-domain]\" serverPort = [FRP-port] auth.token = \"[FRP-token]\" [[proxies]] name = \"Stable-Diffusion\" # 你也可以取其他名字 type = \"tcp\" localIP = \"127.0.0.1\" localPort = 7860 remotePort = 7860 请将 [IP-or-domain]、[FRP-port] 和 [FRP-token] 替换为实际使用的服务器地址端口和 token\n启动 frpc：\n./frpc -c ./frpc.toml 正常启动后便可以访问 http://[IP-or-domain]:7860 来访问 WebUI 并正常的生成图片，所生成的图片会保存到 /workspace/stable-diffusion-webui-forge/outputs 文件夹下\n这样需要创建两个终端分别用于启动 WebUI 和 frpc，这样并不是很方便，我们可以写一个脚本来实现一键启动。\n创建 run.sh：\n#!/bin/bash # 定义一个函数来终止所有后台进程 cleanup() { echo \"正在终止后台进程...\" # 查找并终止所有以当前脚本启动的后台进程 kill $FRP_PID exit 0 } # 捕获 SIGINT 信号（Ctrl+C）并执行 cleanup 函数 trap cleanup SIGINT # 启动 frpc 并将日志保存到 frp.log nohup /workspace/frp/frpc -c /workspace/frp/frpc.toml \u003e /workspace/frp.log 2\u003e\u00261 \u0026 FRP_PID=$! # 启动 stable-diffusion-webui-forge /workspace/stable-diffusion-webui-forge/webui.sh -f ",
  "wordCount" : "465",
  "inLanguage": "en",
  "datePublished": "2025-01-18T00:27:00Z",
  "dateModified": "2025-01-18T00:27:00Z",
  "author":{
    "@type": "Person",
    "name": "WallBreakerNO4"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://100.119.72.3:1313/posts/8.%E7%99%BD%E5%AB%96%E8%85%BE%E8%AE%AF%E4%BA%91gpu%E8%B7%91stable-diffusion-webui/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "WallBreakerNO4的博客",
    "logo": {
      "@type": "ImageObject",
      "url": "http://100.119.72.3:1313/assets/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://100.119.72.3:1313/" accesskey="h" title="WallBreakerNO4的博客 (Alt + H)">WallBreakerNO4的博客</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://100.119.72.3:1313/friends/" title="朋友">
                    <span>朋友</span>
                </a>
            </li>
            <li>
                <a href="http://100.119.72.3:1313/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
            <li>
                <a href="http://100.119.72.3:1313/archives" title="存档">
                    <span>存档</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://100.119.72.3:1313/">Home</a>&nbsp;»&nbsp;<a href="http://100.119.72.3:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      白嫖腾讯云GPU跑Stable Diffusion
    </h1>
    <div class="post-meta"><span title='2025-01-18 00:27:00 +0000 UTC'>January 18, 2025</span>&nbsp;·&nbsp;WallBreakerNO4

</div>
  </header> 
  <div class="post-content"><p>AI 绘画并不是一个离我们很远的话题，随着基于 diffusion 架构的 stable diffusion 的诞生，各式各样的绘图模型如井喷式诞生。如果想在本地跑 AIGC 的绘画软件，那么一块强大的 GPU 是必不可少的。但不是所有人都<del>是臭打游戏的</del>拥有一块 GPU，因此我在这里介绍如何白嫖腾讯云的免费 GPU 来运行 Stable Diffusion WebUI</p>
<blockquote>
<p>感谢 <a href="https://linux.do/t/topic/262176">Linux Do</a> 上的网友将这个白嫖的方法分享出来</p>
</blockquote>
<h2 id="准备">准备<a hidden class="anchor" aria-hidden="true" href="#准备">#</a></h2>
<p>首先打开 <a href="https://ide.cloud.tencent.com/dashboard/gpu-workspace">https://ide.cloud.tencent.com/dashboard/gpu-workspace</a> ，登录后便能进入到这一个界面（图中是我已经创建好的，请忽略）：
<img loading="lazy" src="https://image.wall-breaker-no4.xyz/imgs/202412210041980.png" alt="image.png"  />
</p>
<blockquote>
<p>腾讯云在 Cloud Studio 中提供了一个月 10000 分钟的 GPU 时长（2025 年 1 月 1 日后），免费的 GPU 配置为 Tesla T4，拥有 16G 的显存。这用于跑 Stable Diffusion WebUI 已经绰绰有余了。
美中不足的是，这个在排除了系统自带占用后，只有 30G 的空间，稍微有点小</p>
</blockquote>
<p>新建一个工作空间：
<img loading="lazy" src="https://image.wall-breaker-no4.xyz/imgs/202412210046512.png" alt="image.png"  />
</p>
<p>名称随便，能记住就行，模板选择 Pytorch：
<img loading="lazy" src="https://image.wall-breaker-no4.xyz/imgs/202412210047611.png" alt="image.png"  />
</p>
<p>进入新建好的工作空间 <del>VScode 换皮</del>
<img loading="lazy" src="https://image.wall-breaker-no4.xyz/imgs/202412210122200.png" alt="image.png"  />
</p>
<p>将左侧的示例删除：
<img loading="lazy" src="https://image.wall-breaker-no4.xyz/imgs/202412210124619.png" alt="image.png"  />
</p>
<p>新建一个终端：
<img loading="lazy" src="https://image.wall-breaker-no4.xyz/imgs/202412210126986.png" alt="image.png"  />

<img loading="lazy" src="https://image.wall-breaker-no4.xyz/imgs/202412210127485.png" alt="image.png"  />
</p>
<h2 id="安装-webui">安装 WebUI<a hidden class="anchor" aria-hidden="true" href="#安装-webui">#</a></h2>
<p>克隆项目（使用 Github Proxy 代理）到本地并进入 webui 文件夹：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git clone https://ghfast.top/https://github.com/lllyasviel/stable-diffusion-webui-forge.git
</span></span><span style="display:flex;"><span>cd stable-diffusion-webui-forge
</span></span></code></pre></div><blockquote>
<p>Github Proxy 项目的域名很容易被墙，请去项目最新发布<a href="https://ghproxy.link/">地址</a>查看可用域名，并将后续使用 Github Proxy 的域名替换</p>
</blockquote>
<p>将自带的 pytorch 删除（版本太老了），创建 venv 并安装最新版的 pytorch：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>pip uninstall torch torchvision torchaudio
</span></span><span style="display:flex;"><span>python -m venv venv
</span></span><span style="display:flex;"><span>source venv/bin/activate
</span></span><span style="display:flex;"><span>pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu124
</span></span></code></pre></div><blockquote>
<p>可能会比较慢，但国内没有 pytorch 的镜像源了，只能这样嗯下</p>
</blockquote>
<p>打开 <code>stable-diffusion-webui-forge/modules/launch_utils.py</code> 文件，将里面所有的 <code>https://github.com</code> 替换为 <code>https://ghfast.top/https://github.com</code>，在第一次启动 webui 安装插件时走镜像加速安装
<img loading="lazy" src="https://image.wall-breaker-no4.xyz/imgs/202412210146890.png" alt="image.png"  />
</p>
<blockquote>
<p>使用 <code>ctrl + H</code> 进行替换</p>
</blockquote>
<p>安装工作空间缺失的组件（<code>aria2</code> 是用于下载模型的，如果你喜欢使用 <code>wget</code> 的话就不用安装）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>apt update <span style="color:#f92672">&amp;&amp;</span> apt install aria2 google-perftools bc libgl1 -y
</span></span></code></pre></div><p>修改 <code>stable-diffusion-webui-forge/webui-user.sh</code>，取消 <code>export COMMANDLINE_ARGS=&quot;&quot;</code> 这一行的注释，并修改为：</p>
<pre tabindex="0"><code>export COMMANDLINE_ARGS=&#34;--listen --enable-insecure-extension-access --api --theme dark --cuda-malloc&#34;
</code></pre><p><img loading="lazy" src="https://image.wall-breaker-no4.xyz/imgs/202412210151109.png" alt="image.png"  />
</p>
<p>进入 <code>stable-diffusion-webui-forge/models/Stable-diffusion</code> 下载模型：</p>
<blockquote>
<p>对于画二次元图片，我推荐 Laxhar Dream Lab 训练的 NoobAI-XL 系列模型：<a href="https://huggingface.co/Laxhar">Huggingface 地址</a>，<a href="https://civitai.com/models/833294/noobai-xl-nai-xl">Civitai 地址</a></p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>cd stable-diffusion-webui-forge/models/Stable-diffusion
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 由于 HuggingFace 被墙，使用 HF-mirror 下载</span>
</span></span><span style="display:flex;"><span>aria2c -x <span style="color:#ae81ff">16</span> -o NoobAI-XL-Vpred-v1.0.safetensors <span style="color:#e6db74">&#34;https://hf-mirror.com/Laxhar/noobai-XL-Vpred-1.0/resolve/main/NoobAI-XL-Vpred-v1.0.safetensors?download=true&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># HuggingFace 下载链接</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># aria2c -x 16 -o NoobAI-XL-Vpred-v1.0.safetensors &#34;https://huggingface.co/Laxhar/noobai-XL-Vpred-1.0/resolve/main/NoobAI-XL-Vpred-v1.0.safetensors?download=true&#34;</span>
</span></span></code></pre></div><p>返回 webui 根目录，并启动 webui：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>cd /workspace/stable-diffusion-webui-forge/
</span></span><span style="display:flex;"><span>./webui.sh -f
</span></span></code></pre></div><blockquote>
<p>由于是 root 身份，需要添加 <code>-f</code> 参数才能启动 webui</p>
</blockquote>
<p>终端出现类似以下输出时，webui 便启动成功了</p>
<pre tabindex="0"><code>Running on local URL:  http://0.0.0.0:7860

To create a public link, set `share=True` in `launch()`.
Startup time: 47.7s (prepare environment: 12.1s, launcher: 0.6s, import torch: 12.2s, initialize shared: 0.1s, other imports: 0.5s, load scripts: 2.2s, initialize google blockly: 14.1s, create ui: 2.6s, gradio launch: 1.4s, add APIs: 1.7s).
</code></pre><p><img loading="lazy" src="https://image.wall-breaker-no4.xyz/imgs/202412210226475.png" alt="image.png"  />
</p>
<h2 id="访问-webui">访问 WebUI<a hidden class="anchor" aria-hidden="true" href="#访问-webui">#</a></h2>
<p>由于腾讯云的这个工作空间并不提供外部访问端口的功能，我们需要使用内网穿透工具来访问 webui。市面上有很多内网穿透服务，因此本章仅为抛砖引玉，不一定是最好的解决方案。</p>
<h3 id="webui-自带的穿透">WebUI 自带的穿透<a hidden class="anchor" aria-hidden="true" href="#webui-自带的穿透">#</a></h3>
<p>实际上，WebUI 自带了一个内网穿透功能。WebUI 是基于 Gradio 构建的，而 Guadio 提供了一个公共的穿透服务。只需要修改 <code>stable-diffusion-webui-forge/webui-user.sh</code> 这个文件，同样修改 <code>export COMMANDLINE_ARGS=</code> 这一行，添加 <code>--share</code> 参数即可使用。</p>
<p>这是最简单的方法，但有一个问题：Gradio 提供的服务器在海外，而由于腾讯云这个 ide 在大陆，内网穿透需要来回共两次，因此并不稳定</p>
<h3 id="使用-frp-穿透">使用 FRP 穿透<a hidden class="anchor" aria-hidden="true" href="#使用-frp-穿透">#</a></h3>
<p>FRP 应该是市面上最常见的内网传统工具了，可以选择市面上免费的 frps 服务商或者用自己的服务器搭建一个。</p>
<h4 id="服务商">服务商<a hidden class="anchor" aria-hidden="true" href="#服务商">#</a></h4>
<p>市面上也有很多服务商提供免费的 frps 服务，我在这里推荐几家我曾经用过的（没有 aff）：</p>
<ul>
<li><a href="https://www.natfrp.com/">SAKURA FRP</a></li>
<li><a href="https://freefrp.net/">FreeFRP.NET</a></li>
<li><a href="https://chickfrp.com/">小鸡FRP内网穿透</a></li>
</ul>
<p>如何使用这些服务商请看其对应文档，本文只介绍如何使用自己的服务器搭建 FRP 来访问 WebUI</p>
<h4 id="自己搭建">自己搭建<a hidden class="anchor" aria-hidden="true" href="#自己搭建">#</a></h4>
<p>在搭建前，你需要拥有一个能从公网访问的服务器才能自建 frps（只需要两个端口，实际上提供 NATv4 入口的服务器也是可以的）</p>
<p>我们可以使用 docker compose 来一把梭配置文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">services</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">frps</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">logging</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">options</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">max-size</span>: <span style="color:#ae81ff">16m</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">restart</span>: <span style="color:#ae81ff">unless-stopped</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">network_mode</span>: <span style="color:#ae81ff">host</span> <span style="color:#75715e"># 直接使用 host 模式一把梭</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">volumes</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#e6db74">&#39;./frps.toml:/etc/frp/frps.toml&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">container_name</span>: <span style="color:#ae81ff">frps</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">image</span>: <span style="color:#ae81ff">snowdreamtech/frps</span>
</span></span></code></pre></div><p>然后在同文件夹下编辑 <code>frps.toml</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-frps.toml" data-lang="frps.toml"><span style="display:flex;"><span><span style="color:#a6e22e">bindPort</span> = [<span style="color:#a6e22e">FRP-port</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">auth</span>.<span style="color:#a6e22e">token</span> = <span style="color:#e6db74">&#34;[FRP-token]&#34;</span>
</span></span></code></pre></div><blockquote>
<p>请将 <code>[FRP-port]</code> 和 <code>[FRP-token]</code> 替换为实际使用的端口和 token</p>
</blockquote>
<p>最后启动 docker 容器：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>docker compose up -d
</span></span></code></pre></div><blockquote>
<p>请注意开放服务器的防火墙端口，需要开放两个：<code>[FRP-port]/tcp</code> 和 <code>7860/tcp</code></p>
</blockquote>
<hr>
<p>回到腾讯云 IDE，让我们新建一个终端并创建一个文件夹来放 frpc 相关的文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>cd /workspace/
</span></span><span style="display:flex;"><span>mkdir frp
</span></span><span style="display:flex;"><span>cd frp
</span></span></code></pre></div><p>使用 GitHub Proxy 从 FRP <a href="https://github.com/fatedier/frp">仓库</a>下载 amd64 架构的文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>aria2c -x <span style="color:#ae81ff">16</span> -o frp_0.61.1_linux_amd64.tar.gz <span style="color:#e6db74">&#34;https://ghfast.top/https://github.com/fatedier/frp/releases/download/v0.61.1/frp_0.61.1_linux_amd64.tar.gz&#34;</span>
</span></span></code></pre></div><p>解压文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>tar -zxvf frp_0.61.1_linux_amd64.tar.gz
</span></span></code></pre></div><p>创建 <code>frpc.toml</code> 文件并编辑：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-frpc.toml" data-lang="frpc.toml"><span style="display:flex;"><span><span style="color:#a6e22e">serverAddr</span> = <span style="color:#e6db74">&#34;[IP-or-domain]&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">serverPort</span> = [<span style="color:#a6e22e">FRP-port</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">auth</span>.<span style="color:#a6e22e">token</span> = <span style="color:#e6db74">&#34;[FRP-token]&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[[<span style="color:#a6e22e">proxies</span>]]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">name</span> = <span style="color:#e6db74">&#34;Stable-Diffusion&#34;</span> <span style="color:#75715e"># 你也可以取其他名字</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">type</span> = <span style="color:#e6db74">&#34;tcp&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">localIP</span> = <span style="color:#e6db74">&#34;127.0.0.1&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">localPort</span> = <span style="color:#ae81ff">7860</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">remotePort</span> = <span style="color:#ae81ff">7860</span>
</span></span></code></pre></div><blockquote>
<p>请将 <code>[IP-or-domain]</code>、<code>[FRP-port]</code> 和 <code>[FRP-token]</code> 替换为实际使用的服务器地址端口和 token</p>
</blockquote>
<p>启动 frpc：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>./frpc -c ./frpc.toml
</span></span></code></pre></div><p>正常启动后便可以访问 <code>http://[IP-or-domain]:7860</code> 来访问 WebUI 并正常的生成图片，所生成的图片会保存到 <code>/workspace/stable-diffusion-webui-forge/outputs</code> 文件夹下</p>
<hr>
<p>这样需要创建两个终端分别用于启动 WebUI 和 frpc，这样并不是很方便，我们可以写一个脚本来实现一键启动。</p>
<p>创建 <code>run.sh</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e">#!/bin/bash
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 定义一个函数来终止所有后台进程</span>
</span></span><span style="display:flex;"><span>cleanup<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;正在终止后台进程...&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 查找并终止所有以当前脚本启动的后台进程</span>
</span></span><span style="display:flex;"><span>    kill $FRP_PID
</span></span><span style="display:flex;"><span>    exit <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 捕获 SIGINT 信号（Ctrl+C）并执行 cleanup 函数</span>
</span></span><span style="display:flex;"><span>trap cleanup SIGINT
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 启动 frpc 并将日志保存到 frp.log</span>
</span></span><span style="display:flex;"><span>nohup /workspace/frp/frpc -c /workspace/frp/frpc.toml &gt; /workspace/frp.log 2&gt;&amp;<span style="color:#ae81ff">1</span> &amp;
</span></span><span style="display:flex;"><span>FRP_PID<span style="color:#f92672">=</span>$!
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 启动 stable-diffusion-webui-forge</span>
</span></span><span style="display:flex;"><span>/workspace/stable-diffusion-webui-forge/webui.sh -f
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="next" href="http://100.119.72.3:1313/posts/7.tailscale-%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B---%E5%AD%90%E7%BD%91%E8%B7%AF%E7%94%B1%E5%92%8C%E8%87%AA%E5%BB%BA%E4%B8%AD%E8%BD%AC/">
    <span class="title">Next »</span>
    <br>
    <span>Tailscale 进阶使用教程 - 子网路由和自建中转</span>
  </a>
</nav>

  </footer><script
  src="https://giscus.app/client.js"
  data-repo="WallBreakerNO4/blog"
  data-repo-id="R_kgDOKttXig"
  data-category="Announcements"
  data-category-id="DIC_kwDOKttXis4ChSmC"
  data-mapping="pathname"
  data-strict="0"
  data-reactions-enabled="1"
  data-emit-metadata="0"
  data-input-position="bottom"
  data-theme="noborder_gray"
  data-lang="zh-CN"
  crossorigin="anonymous"
  async
></script>

</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://100.119.72.3:1313/">WallBreakerNO4的博客</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
